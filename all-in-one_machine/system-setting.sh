#!/bin/bash
#andrew ling  2016/10/17

#tool function


#host name list and setting
#/etc/hostname
#hostnamectl
#hostnamectl set-hostname newname
host_name_operation() {
  local operation=$1
  if [ "$operation" == "L" ]; then
    hostname=$(hostnamectl|grep hostname|awk -F' ' '{print $3}')
    echo $hostname
  elif [ "$operation" == "U" ]; then
    newname=$2
    hostnamectl set-hostname $newname
cat > /etc/hostname << EOF
${newname}
EOF
    hostname=$(hostnamectl|grep hostname|awk -F' ' '{print $3}')
    echo $hostname
  else
    exit 2
  fi

}

#system date list, setting, sync
date_operation() {
  local operation=$1
  if [ "$operation" == "L" ]; then
    local_time=$(timedatectl |grep 'Local time')
    time_zone=$(timedatectl |grep Timezone)
    echo ${local_time}','${time_zone}
  elif [ "$operation" == "U" ]; then
    update_time=$2
    update_timezone=$3
    timedatectl set-time "$update_time"
    if [ "$update_timezone" != "" ]; then
      timedatectl set-timezone $update_timezone
    fi
    timedatectl set-ntp yes
    timedatectl set-local-rtc 1
    systemctl restart ntpd

    local_time=$(timedatectl |grep 'Local time')
    time_zone=$(timedatectl |grep Timezone)
    echo ${local_time}','${time_zone}

  elif [ "$operation" == "S" ]; then
    systemctl restart ntpd
    timedatectl set-ntp yes
    ntpq -p
  else
    exit 2
  fi
}

#DNS Server list and update
dns_server_operation() {
  local operation=$1
  if [ "$operation" == "L" ]; then
    nameservers_list=$(cat /etc/resolv.conf |grep 'nameserver '| awk -F' ' '{print $2}')
    nameservers=
    for nameserver in $nameservers_list; do
      nameservers=${nameserver}','${nameservers}
    done
    echo $nameservers
  elif [ "$operation" == "U" ]; then
    nameservers=$2
    cat > /etc/resolv.conf << EOF
# Generated by NetworkManager
# No nameservers found; try putting DNS servers into your
# ifcfg files in /etc/sysconfig/network-scripts like so:
#
# DNS1=xxx.xxx.xxx.xxx
# DNS2=xxx.xxx.xxx.xxx
# DOMAIN=lab.foo.com bar.foo.com
EOF
    nameservers_list=$(echo $nameservers | cut -d, -f1- --output-delimiter=" ")
    for nameserver in $nameservers_list; do
      cat >> /etc/resolv.conf << EOF
nameserver ${nameserver}
EOF
    done

    nameservers_result_list=$(cat /etc/resolv.conf |grep 'nameserver '| awk -F' ' '{print $2}')
    nameservers_result=
    for nameserver in $nameservers_result_list; do
      nameservers_result=${nameserver}','${nameservers_result}
    done
    echo $nameservers_result
  else
    exit 2
  fi
}

#WEB
#http  /etc/httpd/conf/httpd.conf
#https /etc/httpd/conf.d/ssl.conf
web_server_operation() {
  local operation=$1
  if [ "$operation" == "L" ]; then
    http_port=$(cat /etc/httpd/conf/httpd.conf |grep '^Listen '|awk -F' ' '{print $2}')
    https_port=$(cat /etc/httpd/conf.d/ssl.conf |grep '^Listen '|awk -F' ' '{print $2}')
    result_info="http port:"${http_port}";https port:"{https_port}
    echo $result_info
  elif [ "$operation" == "U" ]; then
    http_new_port=$2
    https_new_port=$3
    if [ "$http_new_port" != "-1" ]; then
      #修改配置文件
      http_old_port=$(cat /etc/httpd/conf/httpd.conf |grep '^Listen '|awk -F' ' '{print $2}')
      http_old_info=$(cat /etc/httpd/conf/httpd.conf |grep '^Listen ')
      sed -i s/"${http_old_info}"/"Listen ${http_new_port}"/g /etc/httpd/conf/httpd.conf
      #修改防火墙
      iptables -D INPUT -p tcp -m state --state NEW -m tcp --dport $http_old_port -j ACCEPT
      iptables -I INPUT -p tcp -m state --state NEW -m tcp --dport $http_new_port -j ACCEPT
      
    fi

    if [ "$https_new_port" != "-1" ]; then
      #修改配置文件
      https_old_port=$(cat /etc/httpd/conf.d/ssl.conf |grep '^Listen '|awk -F' ' '{print $2}')
      https_old_info_1=$(cat /etc/httpd/conf.d/ssl.conf |grep '^Listen ')
      https_old_info_2=$(cat /etc/httpd/conf.d/ssl.conf |grep '^ServerName ')
      https_old_info_3=$(cat /etc/httpd/conf.d/ssl.conf |grep '^<VirtualHost _default_:')
      sed -i s/"${https_old_info_1}"/"Listen ${https_new_port} https"/g /etc/httpd/conf.d/ssl.conf
      https_new_info_2=$(echo $https_old_info_2 |awk -F':' '{print $1}')
      sed -i s/"${https_old_info_2}"/"${https_new_info_2}:${https_new_port}"/g /etc/httpd/conf.d/ssl.conf
      sed -i s/"${https_old_info_3}"/"<VirtualHost _default_:${https_new_port}>"/g /etc/httpd/conf.d/ssl.conf
      #修改防火墙
      iptables -D INPUT -p tcp -m state --state NEW -m tcp --dport $https_old_port -j ACCEPT
      iptables -I INPUT -p tcp -m state --state NEW -m tcp --dport $https_new_port -j ACCEPT
    fi

    if [ "$http_new_port" == "-1" ] && [ "$https_new_port" == "-1" ]; then
      exit 2
    fi

    service iptables save
    systemctl restart httpd

  else
    exit 2
  fi

}

#ssh server start/stop,set the port of the ssh server
ssh_server_operation() {
  local operation=$1
  local port=$2
  if [ "$operation" == "start" ]; then
    service sshd start
    exit $?
  elif [ "$operation" == "stop" ]; then
    service sshd stop
    exit $?
  else
    exit 2
  fi

  if [ "$port" != "-1" ]; then
    #修改配置文件
    old_info=
    dir_paths=$(whereis ssh)
    for dir in $dir_paths; do
      if [ -d $dir ]; then
        if [ -e ${dir}/sshd_config ]; then
          old_info=$(cat ${dir}/sshd_config |grep 'Port ')
          sed  -i s/"${old_info}"/"Port ${port}"/g ${dir}/sshd_config
        fi
      fi
    done

    #修改防火墙
    old_port=$(echo $old_info|awk -F' ' '{print $2}')
    iptables -D INPUT -p tcp -m state --state NEW -m tcp --dport $old_port -j ACCEPT
    iptables -I INPUT -p tcp -m state --state NEW -m tcp --dport $port -j ACCEPT
    service iptables save

    #重启shhd服务
    service sshd restart

  fi

}

#The port of PING open/close in the firewall
#iptables -I INPUT -p icmp -j DROP
#iptables -I OUTPUT -p icmp -j DROP
#iptables -I INPUT -p icmp -j ACCEPT
#iptables -I OUTPUT -p icmp -j ACCEPT
ping_firewall_operation() {
  local operation=$1
  if [ "$operation" == "open" ]; then
    iptables -D INPUT -p icmp -j DROP
    iptables -D OUTPUT -p icmp -j DROP
    (iptables -I INPUT -p icmp -j ACCEPT) && (iptables -I OUTPUT -p icmp -j ACCEPT)
    exit $?
  elif [ "$operation" == "close" ]; then
    iptables -D INPUT -p icmp -j ACCEPT
    iptables -D OUTPUT -p icmp -j ACCEPT
    (iptables -I INPUT -p icmp -j DROP) && (iptables -I OUTPUT -p icmp -j DROP)
    exit $?
  else
    exit 2
  fi

}


hostname=
update_time=
update_timezone=
nameservers=
http_new_port="-1"
https_new_port="-1"
ssh_update_port="-1"

while getopts 't:LUn:d:z:Ss:h:H:o:p:' OPTION
do
  case $OPTION in
    t) op_type="$OPTARG"
      Tflag=1
      ;;
    L) Lflag=1
      operation="L"
      ;;
    U) Uflag=1
      operation="U"
      ;;
    n) hostname="$OPTARG"
      ;;
    d) update_time="$OPTARG"
      ;;
    z) update_timezone="$OPTARG"
      ;;
    S) Sflag=1
      operation="S"
      ;;
    s) nameservers="$OPTARG"
      ;;
    h) http_new_port="$OPTARG"
      ;;
    H) https_new_port="$OPTARG"
      ;;
    o) service_op="$OPTARG"
      ;;
    p) ssh_update_port="$OPTARG"
      ;;
    ?) echo $"Usage : The parameters input error"
      exit 2
      ;;
  esac
done

if [ "$Tflag$Lflag$Uflag$Sflag" != "11" ]
then
    exit 2
fi

if [ "$Tflag" == "1" ]; then
  #host name part
  if [ "$op_type" == "host" ]; then
    host_name_operation $operation $hostname
  fi

  #system date part
  if [ "$op_type" == "date" ]; then
    date_operation $operation $update_time $update_timezone
  fi

  #DNS part
  if [ "$op_type" == "dns" ]; then
    dns_server_operation $operation $nameservers
  fi

  #apache web part
  if [ "$op_type" == "web" ]; then
    web_server_operation $operation $http_new_port $https_new_port
  fi

  #ssh part
  if [ "$op_type" == "ssh" ]; then
    ssh_server_operation $service_op $ssh_update_port
  fi

  #ping part
  if [ "$op_type" == "ping" ]; then
    ping_firewall_operation $service_op
  fi

else
  exit 2
fi

exit 0